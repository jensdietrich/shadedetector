\documentclass{article}

\usepackage{url}
\usepackage{todonotes}


\begin{document}


\title{Dependency Shading in the Maven Ecosystem}


\maketitle

\abstract{
Modern software heavily relies on the use of components. Those components are usually published  in central repositories, and managed by build systems via dependencies. Due to issues around vulnerabilities, licenses and the propagation of bugs, the study of those dependencies is of upmost importance, and new software composition analysis tools have emerged to deal with those challenges. 

A particular challenge those tools phase is obfuscated dependencies that are the result of shading where code from a component is "inlined" into a client, and often moved into a different namespace. 

We study the practice of shading, and how prevalent this is in the Maven ecosystem used by Java and other JVM languages (Kotlin, Scala, etc). We also present tooling to detect shaded dependencies. 

}

\section{Introduction}


Modern software systems often use components to obtain economy of scale. The process is recursive -- components also use other components, resulting in deep and complex component ecosystems. This has in turn created new challenges. The prime example is vulnerability propagation, infamous examples include the \textit{equifax}~\cite{CVE-2017-5638,luszcz2018apache} and \textit{log4shell}~\cite{CVE-2021-44228,hiesgen2022race} incidents, with vulnerable and oudated components now being acknowledged as being a major security risk~\cite{owaspTop10A06}. 

In response to those challenges, software composition analysis (SCA)  tools have emerged that scan the dependency networks, and cross-reference them with known vulnerabilities, in particular, the common vulnerability and exposure (CVE) database. If a vulnerable dependency is found, developers are notified (usually via pull requests) and can upgrade dependencies to a newer version. This is also beneficial for other reasons resulting from maintenance, such as bug fixes. Examples of such tools include GitHub's \textit{dependabot}~\footnote{\url{https://github.com/dependabot}}, \textit{snyk}~\footnote{\url{https://snyk.io/}},
\textit{OWASP dependency check}~\footnote{\url{https://owasp.org/www-project-dependency-check/}},  tooling integrated into development environments such as \textit{IntelliJ's dependency analysis},  and features or plugins for build tools like \textit{npm audit} (for JavaScript) and sonatype's \textit{oss index} Maven plugin~\footnote{\url{https://sonatype.github.io/ossindex-maven/maven-plugin/}}.
 
 Those are static analysis tools, mainly based on the project metadata - declarations of dependencies in build configurations files. Like all such tools they suffer from precision problems, i.e. false positives. They may for instance detect dependencies to vulnerable code in a  library that is not actually reachable. This could in principle be tackled by building more fine-grained analyses, although the price (in terms of computational resources needed) is significant. 
 
What is more  relevant for our discussion  is that those analyses are not sound either, but merely \textit{soundy}~\cite{livshits2015defense}. I.e. those tools are sound only under certain assumptions, but there are known circumstances when those analyses produce false negatives, i.e., they miss dependencies and therefore problems such as vulnerabilities associated with those dependencies.
 
 The first such pattern is late binding, i.e. applications that "discover" capabilities at runtime, leading to dependencies that are not visible in the build configurations or code SCA tools analyse.  For Java, plugin-based application frameworks like \textit{OSGi} widely used in application servers and programming tools (Eclipse) facilitate this.  
 
 A second cause of unsoundness is \textit{dependency shading}.  With shading, packages of Java code are inlined into an application, i.e. included in the library or application (usually a \textit{jar} file) being build. One reason to do this is to build a far jar or super jar, i.e. the application is packaged in a format that facilitates deployment by including all dependencies, therefore not requiring the tedious configuration of classpaths. For this use case, packages retain their packages (name spaces). Shading occurs when the package names are changed, therefore obfuscating the origin of the code being shaded. The main use case to do this is to avoid conflicts that occur if two versions of the same class (identified by the fully qualified name that includes the package name) occur in the classpath~\cite{wang2018dependency}. Unless complex frameworks are used to mitigate this using class loaders (such as OSGi), this results in unpredictable behaviour, sometimes referred to as classpath hell in reference to the DLL hell that plagued Windows software for many year. 
 
 Renaming packages is not a trivial task and references must be updated, the this requires an analysis that may itself be unsound, for instance, if reflective references to code to be shaded exist~\cite{sui2020recall}. For this reason, build plugins have emerged to facilitate shading. The prime example of such a plugin is the \textit{maven-shade-plugin}~\footnote{\url{https://maven.apache.org/plugins/maven-shade-plugin/}}. In particular, the plugin allows users to define relocations by specifying source and target packages. This make the process of shading accessible to developers.  
 
 We refer to this as \textit{guided shading}, i.e. shading that is supported by a build tool that performs some analysis (although unsound, as discussed above). In contrast, \textit{ad-hoc shading} refers to shading where developers copy code (usually source code) into a project.  In terms of SCA, guided shading is somehow more benign as the original dependencies contain the code that is being shaded are still visible for tools.  
 
It is also possible and often sensible not to shade an entire library, but only the parts needed. This can reduce the size of packages build, and reduce exposure to vulnerabilities. We refer to this practice as \textit{partial shading}. 
 
\todo[inline] {need to discuss the gradle equivalent for shading somewhere}
 
 
\todo[inline] {todo can somewhere discuss story how shading undermines design principles like LSP}
 


\subsection{Research Questions}

\begin{enumerate}
	\item[RQ1]  How prevalent is shading in the Maven ecosystem ?  
	\item[RQ2] How is shading done ?
	\begin{enumerate}
		\item[RQ2a] How prevalent is ad-hoc shading ?
		\item[RQ2b] How common is relocation ?
		\item[RQ2c] How common is partial shading ?
	\end{enumerate}
	\item[RQ3] Which libraries are commonly being shaded ? 
	\item[RQ4] What are the reasons to use shading ?
	\item[RQ5] What are the limitations of current tools with respect to shading ?
	\item[RQ6] Can shaded dependencies be efficiently detected ? 
\end{enumerate}


\todo[inline] {Emanuel did some experiments for RQ5 using dependabot, synk, owasp and IntelliJâ€™s Dependency Analysis -- this is not in the final report, we can tidy this up / redo this easily}

\section{Related Work}



\section{Dataset Acquisition}



\section{Acknowledgements}

\bibliographystyle{plain}
\bibliography{bibliography}

\end{document}